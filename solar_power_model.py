import aerosandbox.numpy as np
import matplotlib.pyplot as plt

class Power:
    """
    A class to model solar power generation and consumption over a day 
    based on location, date, and system parameters.
    """

    def __init__(self, latitude: float, day_of_year: int, area: float, power_required=None, max_irradiance: float = 1300, efficiency: float = 0.3):
        """
        Initialize the Power model.

        Parameters:
            latitude (float): Geographic latitude in degrees.
            day_of_year (int): Day of the year (1 to 365).
            area (float): Area of the solar panel in square meters.
            power_required (array-like or None): Required power over time (in W). Defaults to zero.
            max_irradiance (float): Max solar irradiance at noon (W/m²). Default is 1000.
            efficiency (float): Efficiency of the solar panels. Default is 0.2 (20%).
        """
        self.latitude = np.radians(latitude)
        self.day_of_year = day_of_year
        self.max_irradiance = max_irradiance
        self.efficiency = efficiency
        self.seconds_in_day = 86400
        self.seconds = np.arange(self.seconds_in_day)
        self.area = area
        self.irradiance = self._compute_irradiance() 
        self.power_required = (
            np.array(power_required) / area if power_required is not None
            else np.zeros(self.seconds_in_day)
        )

    def _declination(self):
        """
        Compute the solar declination angle for the given day of the year.

        Returns:
            float: Declination angle in radians.
        """
        return np.radians(23.45) * np.sin(np.radians(360 / 365 * (284 + self.day_of_year)))

    def _hour_angle(self):
        """
        Compute the solar hour angle for each second in the day.

        Returns:
            ndarray: Hour angle in radians at each second of the day.
        """
        solar_time = self.seconds / 3600  # in hours
        ha_deg = (solar_time - 12) * 15
        return np.radians(ha_deg)

    def _solar_elevation(self):
        """
        Compute the solar elevation angle throughout the day.

        Returns:
            ndarray: Solar elevation angle in radians at each second.
        """
        decl = self._declination()
        ha = self._hour_angle()
        return np.arcsin(
            np.sin(self.latitude) * np.sin(decl) +
            np.cos(self.latitude) * np.cos(decl) * np.cos(ha)
        )

    def _compute_irradiance(self):
        """
        Compute raw solar irradiance on the panel area over time.

        Returns:
            ndarray: Instantaneous power incident on the panel (in W).
        """
        elevation = self._solar_elevation()
        raw_irradiance = self.max_irradiance * np.sin(elevation)
        raw_irradiance[elevation <= 0] = 0
        return raw_irradiance 

    def power_generated(self):
        """
        Compute electrical power generated by the solar panel.

        Returns:
            ndarray: Power generated (in W) at each second.
        """
        return self.irradiance * self.efficiency 

    def net_power(self):
        """
        Compute the net power (generated - required) over time.

        Returns:
            ndarray: Net power (in W) at each second.
        """
        return self.power_generated() - self.power_required

    def net_energy(self):
        """
        Compute cumulative net energy over the day.

        Returns:
            ndarray: Net energy (in J) at each second (cumulative sum).
        """
        return np.cumsum(self.net_power())

    def max_surplus(self):
        """
        Get the maximum energy surplus during the day.

        Returns:
            float or None: Maximum net energy (J), or None if no surplus.
        """
        net = self.net_energy()
        return net.max() * self.area

    def max_deficit(self):
        """
        Get the maximum energy deficit during the day.

        Returns:
            float or None: Minimum net energy (J), or None if no deficit.
        """
        net = self.net_energy()
        return net.min() * self.area
    
    def plot_power_profiles(self):
        """
        Plot power generation, requirement, and cumulative energy over time.
        """
        seconds = self.seconds
        generated = self.power_generated()
        required = self.power_required
        net = self.net_power()
        energy = self.net_energy()

        fig, ax1 = plt.subplots(2, 1, figsize=(14, 8), sharex=True)

        # Plot power values
        ax1[0].plot(seconds, generated, label='Power Generated (W)', color='green')
        ax1[0].plot(seconds, required, label='Power Required (W)', color='red', linestyle='--')
        ax1[0].plot(seconds, net, label='Net Power (W)', color='blue')
        ax1[0].set_ylabel('Power (W)')
        ax1[0].legend()
        ax1[0].grid(True)
        ax1[0].set_title('Power Profiles Throughout the Day')

        # Plot net energy
        ax1[1].plot(seconds, energy, label='Net Energy (J)', color='purple')
        ax1[1].set_ylabel('Energy (J)')
        ax1[1].set_xlabel('Seconds Since Midnight')
        ax1[1].legend()
        ax1[1].grid(True)
        ax1[1].set_title('Cumulative Net Energy')

        plt.tight_layout()
        plt.show()



def night_length(latitude, day_of_year):
    """
    Calculate the length of the night (in seconds) for a given day of the year at a specific latitude.
    
    :param latitude: Latitude of the observer in degrees.
    :param day_of_year: Day of the year (1 to 365).
    
    :return: Length of the night in seconds.
    """
    # Solar declination (δ) calculation
    declination = 23.44 * np.sin(np.deg2rad(360 * (day_of_year + 10) / 365))
    
    # Convert latitude and declination to radians
    latitude_rad = np.deg2rad(latitude)
    declination_rad = np.deg2rad(declination)
    
    # Calculate the hour angle (H) at sunrise/sunset
    try:
        hour_angle = np.arccos(-np.tan(latitude_rad) * np.tan(declination_rad))
    except ValueError:
        # For polar regions where the sun is always above or below the horizon
        return 0 if abs(latitude) > 66.5 else 86400  # 24 hours of night or no night
    
    # Calculate the length of the day in hours (2 * hour angle / 15° per hour)
    day_length_hours = (2 * hour_angle) / np.deg2rad(15)
    
    # Length of the night in hours
    night_length_hours = 24 - day_length_hours
    
    # Convert night length from hours to seconds
    night_length_seconds = night_length_hours * 3600
    
    return night_length_seconds


if __name__ == "__main__":
    seconds_in_day = 86400
    time = np.arange(seconds_in_day)
    amplitude = 200  # Max power required in watts
    power_required = amplitude * (1 + np.sin(2 * np.pi * time / seconds_in_day))  # Sine wave with period of 24 hours

    power = Power(latitude=0, day_of_year=1, area=10, power_required=power_required)

    print('Deficit: ', power.max_deficit())
    print('Surplus: ', power.max_surplus())

    power.plot_power_profiles()
